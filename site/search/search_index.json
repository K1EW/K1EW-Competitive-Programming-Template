{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"K1EW Competitive Programming Template Welcome \u2014 this site hosts my CP template in Markdown.","title":"Home"},{"location":"#k1ew-competitive-programming-template","text":"Welcome \u2014 this site hosts my CP template in Markdown.","title":"K1EW Competitive Programming Template"},{"location":"template/","text":"Template Fast IO std::ios_base::sync_with_stdio(false); std::cin.tie(0); Disjoint Set Union struct DSU { vector<int> parent; vector<int> rank; DSU(int n) { parent.assign(n+5, 0); rank.assign(n+5, 0); for (int i=1;i<=n;i++) { parent[i] = i; } } int find(int u) { if (parent[u] == u) { return u; } return parent[u] = find(parent[u]); } void union_sets(int u, int v) { u = find(u); v = find(v); if (u != v) { if (rank[u] < rank[v]) { swap(u, v); } parent[v] = u; rank[u] += rank[v]; } } }; Segment Tree // Example: max point update & max range query struct SegTree { vector<int> tree; SegTree(int n) { tree.assign(4*n+5, 0); } int merge_segment(const int &seg1, const int &seg2) { return max(seg1, seg2); } void build(int a[], int v, int tl, int tr) { if (tl == tr) { tree[v] = a[tl]; } else { int tm = (tl + tr) >> 1; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } void update(int v, int tl, int tr, int pos, int val) { if (tl == tr) { tree[v] = max(tree[v], val); } else { int tm = (tl + tr) >> 1; if (pos <= tm) { update(v*2, tl, tm, pos, val); } else { update(v*2+1, tm+1, tr, pos, val); } tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } int query(int v, int tl, int tr, int l, int r) { if (tr < l || r < tl) { return 0; } if (l <= tl && tr <= r) { return tree[v]; } int tm = (tl + tr) >> 1; return merge_segment( query(v*2, tl, tm, l, r), query(v*2+1, tm+1, tr, l, r) ); } }; Lazy Propagation Segment Tree // Example: sum range update & range query struct LazySegTree { vector<int> tree; vector<int> lazy; LazySegTree(int n) { tree.assign(4*n+5, 0); lazy.assign(4*n+5, 0); } int merge_segment(const int &seg1, const int &seg2) { return seg1 + seg2; } void apply(int v, int x, int tl, int tr) { tree[v] += x * (tr - tl + 1); lazy[v] += x; } void push(int v, int tl, int tr) { if (!lazy[v]) { return; } int tm = (tl + tr) >> 1; apply(v*2, lazy[v], tl, tm); apply(v*2+1, lazy[v], tm+1, tr); lazy[v] = 0; } void build(int a[], int v, int tl, int tr) { if (tl == tr) { tree[v] = a[tl]; } else { int tm = (tl + tr) >> 1; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } void update(int v, int tl, int tr, int l, int r, int val) { if (tr < l || r < tl) { return; } if (l <= tl && tr <= r) { apply(v, val, tl, tr); } else { push(v, tl, tr); int tm = (tl + tr) >> 1; update(v*2, tl, tm, l, r, val); update(v*2+1, tm+1, tr, l, r, val); tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } int query(int v, int tl, int tr, int l, int r) { if (tr < l || r < tl) { return 0; } if (l <= tl && tr <= r) { return tree[v]; } push(v, tl, tr); int tm = (tl + tr) >> 1; return merge_segment( query(v*2, tl, tm, l, r), query(v*2+1, tm+1, tr, l, r) ); } }; Heavy-Light Decomposition vector<int> adj[MXN]; int sz[MXN], parent[MXN], depth[MXN], tin[MXN], tout[MXN], top[MXN]; int n; void dfs1(int u, int p) { sz[u] = 1; vector<int> children; for (auto v : adj[u]) { if (v == p) { continue; } depth[v] = depth[u] + 1; dfs1(v, u); children.emplace_back(v); sz[u] += sz[v]; parent[v] = u; } swap(adj[u], children); } int dfs2(int u, int timer) { tin[u] = timer; for (auto v : adj[u]) { if (v == adj[u][0]) { top[v] = top[u]; } else { top[v] = v; } timer = dfs2(v, timer+1); } tout[u] = timer + 1; return timer; } void hld(int root) { dfs1(root, -1); for (int i=1;i<=n;i++) { sort(adj[i].begin(), adj[i].end(), [&](const int &u, const int &v) { return sz[u] > sz[v]; }); } top[root] = root; dfs2(root, 1); } void point_update(SegTree &segtree, int u, int val) { segtree.update(1, 1, n, tin[u], val); } int query_subtree(SegTree &segtree, int u) { return segtree.query(1, 1, n, tin[u], tout[u] - 1); } int query_path(SegTree &segtree, int u, int v) { int res = 0; while (top[u] != top[v]) { if (depth[top[u]] < depth[top[v]]) { swap(u, v); } res = segtree.merge_segment(res, segtree.query(1, 1, n, tin[top[u]], tin[u])); u = parent[top[u]]; } res = segtree.merge_segment(res, segtree.query(1, 1, n, min(tin[u], tin[v]), max(tin[u], tin[v]))); return res; } Heavy-Light Decomposition with Range Update void range_update(LazySegTree &segtree, int u, int v, int val) { while (top[u] != top[v]) { if (depth[top[u]] < depth[top[v]]) { swap(u, v); } segtree.update(1, 1, n, tin[top[u]], tin[u], val); u = parent[top[u]]; } segtree.update(1, 1, n, min(tin[u], tin[v]), max(tin[u], tin[v]), val); } Mo's algorithm #define BLOCK_SIZE 450 void add(int idx) { } void remove(int idx) { } struct Query { int l, r, idx; Query(int l, int r, int idx) { this->l = l; this->r = r; this->idx = idx; } bool operator<(const Query &other) const { if (l / BLOCK_SIZE != other.l / BLOCK_SIZE) { return make_pair(l / BLOCK_SIZE, r) < make_pair(other.l / BLOCK_SIZE, other.r); } return (l / BLOCK_SIZE % 2) ? (r < other.r) : (r > other.r); } }; vector<int> mo(int q, vector<Query> &queries) { vector<int> ans(q); sort(queries.begin(), queries.end()); int l = 1, r = 0; for (Query q : queries) { while (r < q.r) { add(++r); } while (r > q.r) { remove(r--); } while (l > q.l) { add(--l); } while (l < q.l) { remove(l++); } // ans[q.idx] = ... } return ans; } Strongly Connected Component void dfs(int u, vector<int> adj[], vector<bool> &vis, vector<int> &output) { vis[u] = true; for (auto v : adj[u]) { if (vis[v]) { continue; } dfs(v, adj, vis, output); } output.emplace_back(u); } vector<int> find_scc(int n, vector<int> adj[]) { vector<int> scc(n+5); vector<int> order; vector<bool> vis(n+5); for (int v=1;v<=n;v++) { if (vis[v]) { continue; } dfs(v, adj, vis, order); } vector<int> adj_T[n+5]; for (int u=1;u<=n;u++) { adj[u].clear(); } for (int u=1;u<=n;u++) { for (auto v: adj[u]) { adj_T[v].emplace_back(u); } } vis.assign(n+5, false); reverse(order.begin(), order.end()); for (auto u : order) { if (vis[u]) { continue; } vector<int> component; dfs(u, adj_T, vis, component); int root = *min_element(component.begin(), component.end()); for (auto v : adj[u]) { scc[v] = u; } } return scc; } Inverse Modulo #define MOD ... // a in range [1...m-1] int inv(int a) { return a <= 1 ? a : MOD - (long long)(MOD/a) * inv(MOD % a) % MOD; } // Precompute all modulo inverse [1...m-1] int inv[MOD]; inv[1] = 1; for(int a = 2; a < MOD; ++a) { inv[a] = MOD - (long long)(MOD/a) * inv[MOD%a] % MOD; } Sieve of Eratosthenes // Function to precompute all factors for numbers from 1..N vector<vector<int>> compute_factors(int N) { vector<vector<int>> factors(N + 1); for (int i = 1; i <= N; ++i) { for (int j = i; j <= N; j += i) { factors[j].push_back(i); } } return factors; } // Precompute all primes up to N using Sieve of Eratosthenes vector<bool> compute_primes(int N) { vector<bool> is_prime(N + 1, true); is_prime[0] = is_prime[1] = false; for (int i = 2; i * i <= N; ++i) { if (is_prime[i]) { for (int j = i * i; j <= N; j += i) { is_prime[j] = false; } } } return is_primes; } Graham's scan struct pt { long long x, y; pt() {} pt(long long _x, long long _y) : x(_x), y(_y) {} pt operator+(const pt &p) const { return pt(x + p.x, y + p.y); } pt operator-(const pt &p) const { return pt(x - p.x, y - p.y); } long long cross(const pt &p) const { return x * p.y - y * p.x; } long long dot(const pt &p) const { return x * p.x + y * p.y; } long long cross(const pt &a, const pt &b) const { return (a - *this).cross(b - *this); } long long dot(const pt &a, const pt &b) const { return (a - *this).dot(b - *this); } long long sqrLen() const { return this->dot(*this); } bool operator==(const pt& t) const { return x == t.x && y == t.y; } }; int orientation(const pt &a, const pt &b, const pt &c) { long long v = a.cross(b, c); if (v < 0) return -1; // clockwise if (v > 0) return 1; // counter-clockwise return 0; // collinear } bool cw(const pt &a, const pt &b, const pt &c, bool include_collinear) { int o = orientation(a, b, c); return o < 0 || (include_collinear && o == 0); } bool collinear(const pt &a, const pt &b, const pt &c) { return orientation(a, b, c) == 0; } void convex_hull(vector<pt>& a, bool include_collinear = false) { if (a.size() <= 1) return; pt p0 = *min_element(a.begin(), a.end(), [](const pt &a, const pt &b) { return make_pair(a.y, a.x) < make_pair(b.y, b.x); }); sort(a.begin(), a.end(), [&p0](const pt &a, const pt &b) { int o = orientation(p0, a, b); if (o == 0) // collinear, closer first return (p0 - a).sqrLen() < (p0 - b).sqrLen(); return o < 0; // clockwise order }); if (include_collinear) { int i = (int)a.size() - 1; while (i >= 0 && collinear(p0, a[i], a.back())) i--; reverse(a.begin() + i + 1, a.end()); } vector<pt> st; for (int i = 0; i < (int)a.size(); i++) { while (st.size() > 1 && !cw(st[st.size()-2], st.back(), a[i], include_collinear)) st.pop_back(); st.push_back(a[i]); } if (!include_collinear && st.size() == 2 && st[0] == st[1]) st.pop_back(); a = st; }","title":"Template"},{"location":"template/#template","text":"","title":"Template"},{"location":"template/#fast-io","text":"std::ios_base::sync_with_stdio(false); std::cin.tie(0);","title":"Fast IO"},{"location":"template/#disjoint-set-union","text":"struct DSU { vector<int> parent; vector<int> rank; DSU(int n) { parent.assign(n+5, 0); rank.assign(n+5, 0); for (int i=1;i<=n;i++) { parent[i] = i; } } int find(int u) { if (parent[u] == u) { return u; } return parent[u] = find(parent[u]); } void union_sets(int u, int v) { u = find(u); v = find(v); if (u != v) { if (rank[u] < rank[v]) { swap(u, v); } parent[v] = u; rank[u] += rank[v]; } } };","title":"Disjoint Set Union"},{"location":"template/#segment-tree","text":"// Example: max point update & max range query struct SegTree { vector<int> tree; SegTree(int n) { tree.assign(4*n+5, 0); } int merge_segment(const int &seg1, const int &seg2) { return max(seg1, seg2); } void build(int a[], int v, int tl, int tr) { if (tl == tr) { tree[v] = a[tl]; } else { int tm = (tl + tr) >> 1; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } void update(int v, int tl, int tr, int pos, int val) { if (tl == tr) { tree[v] = max(tree[v], val); } else { int tm = (tl + tr) >> 1; if (pos <= tm) { update(v*2, tl, tm, pos, val); } else { update(v*2+1, tm+1, tr, pos, val); } tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } int query(int v, int tl, int tr, int l, int r) { if (tr < l || r < tl) { return 0; } if (l <= tl && tr <= r) { return tree[v]; } int tm = (tl + tr) >> 1; return merge_segment( query(v*2, tl, tm, l, r), query(v*2+1, tm+1, tr, l, r) ); } };","title":"Segment Tree"},{"location":"template/#lazy-propagation-segment-tree","text":"// Example: sum range update & range query struct LazySegTree { vector<int> tree; vector<int> lazy; LazySegTree(int n) { tree.assign(4*n+5, 0); lazy.assign(4*n+5, 0); } int merge_segment(const int &seg1, const int &seg2) { return seg1 + seg2; } void apply(int v, int x, int tl, int tr) { tree[v] += x * (tr - tl + 1); lazy[v] += x; } void push(int v, int tl, int tr) { if (!lazy[v]) { return; } int tm = (tl + tr) >> 1; apply(v*2, lazy[v], tl, tm); apply(v*2+1, lazy[v], tm+1, tr); lazy[v] = 0; } void build(int a[], int v, int tl, int tr) { if (tl == tr) { tree[v] = a[tl]; } else { int tm = (tl + tr) >> 1; build(a, v*2, tl, tm); build(a, v*2+1, tm+1, tr); tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } void update(int v, int tl, int tr, int l, int r, int val) { if (tr < l || r < tl) { return; } if (l <= tl && tr <= r) { apply(v, val, tl, tr); } else { push(v, tl, tr); int tm = (tl + tr) >> 1; update(v*2, tl, tm, l, r, val); update(v*2+1, tm+1, tr, l, r, val); tree[v] = merge_segment(tree[v*2], tree[v*2+1]); } } int query(int v, int tl, int tr, int l, int r) { if (tr < l || r < tl) { return 0; } if (l <= tl && tr <= r) { return tree[v]; } push(v, tl, tr); int tm = (tl + tr) >> 1; return merge_segment( query(v*2, tl, tm, l, r), query(v*2+1, tm+1, tr, l, r) ); } };","title":"Lazy Propagation Segment Tree"},{"location":"template/#heavy-light-decomposition","text":"vector<int> adj[MXN]; int sz[MXN], parent[MXN], depth[MXN], tin[MXN], tout[MXN], top[MXN]; int n; void dfs1(int u, int p) { sz[u] = 1; vector<int> children; for (auto v : adj[u]) { if (v == p) { continue; } depth[v] = depth[u] + 1; dfs1(v, u); children.emplace_back(v); sz[u] += sz[v]; parent[v] = u; } swap(adj[u], children); } int dfs2(int u, int timer) { tin[u] = timer; for (auto v : adj[u]) { if (v == adj[u][0]) { top[v] = top[u]; } else { top[v] = v; } timer = dfs2(v, timer+1); } tout[u] = timer + 1; return timer; } void hld(int root) { dfs1(root, -1); for (int i=1;i<=n;i++) { sort(adj[i].begin(), adj[i].end(), [&](const int &u, const int &v) { return sz[u] > sz[v]; }); } top[root] = root; dfs2(root, 1); } void point_update(SegTree &segtree, int u, int val) { segtree.update(1, 1, n, tin[u], val); } int query_subtree(SegTree &segtree, int u) { return segtree.query(1, 1, n, tin[u], tout[u] - 1); } int query_path(SegTree &segtree, int u, int v) { int res = 0; while (top[u] != top[v]) { if (depth[top[u]] < depth[top[v]]) { swap(u, v); } res = segtree.merge_segment(res, segtree.query(1, 1, n, tin[top[u]], tin[u])); u = parent[top[u]]; } res = segtree.merge_segment(res, segtree.query(1, 1, n, min(tin[u], tin[v]), max(tin[u], tin[v]))); return res; }","title":"Heavy-Light Decomposition"},{"location":"template/#heavy-light-decomposition-with-range-update","text":"void range_update(LazySegTree &segtree, int u, int v, int val) { while (top[u] != top[v]) { if (depth[top[u]] < depth[top[v]]) { swap(u, v); } segtree.update(1, 1, n, tin[top[u]], tin[u], val); u = parent[top[u]]; } segtree.update(1, 1, n, min(tin[u], tin[v]), max(tin[u], tin[v]), val); }","title":"Heavy-Light Decomposition with Range Update"},{"location":"template/#mos-algorithm","text":"#define BLOCK_SIZE 450 void add(int idx) { } void remove(int idx) { } struct Query { int l, r, idx; Query(int l, int r, int idx) { this->l = l; this->r = r; this->idx = idx; } bool operator<(const Query &other) const { if (l / BLOCK_SIZE != other.l / BLOCK_SIZE) { return make_pair(l / BLOCK_SIZE, r) < make_pair(other.l / BLOCK_SIZE, other.r); } return (l / BLOCK_SIZE % 2) ? (r < other.r) : (r > other.r); } }; vector<int> mo(int q, vector<Query> &queries) { vector<int> ans(q); sort(queries.begin(), queries.end()); int l = 1, r = 0; for (Query q : queries) { while (r < q.r) { add(++r); } while (r > q.r) { remove(r--); } while (l > q.l) { add(--l); } while (l < q.l) { remove(l++); } // ans[q.idx] = ... } return ans; }","title":"Mo's algorithm"},{"location":"template/#strongly-connected-component","text":"void dfs(int u, vector<int> adj[], vector<bool> &vis, vector<int> &output) { vis[u] = true; for (auto v : adj[u]) { if (vis[v]) { continue; } dfs(v, adj, vis, output); } output.emplace_back(u); } vector<int> find_scc(int n, vector<int> adj[]) { vector<int> scc(n+5); vector<int> order; vector<bool> vis(n+5); for (int v=1;v<=n;v++) { if (vis[v]) { continue; } dfs(v, adj, vis, order); } vector<int> adj_T[n+5]; for (int u=1;u<=n;u++) { adj[u].clear(); } for (int u=1;u<=n;u++) { for (auto v: adj[u]) { adj_T[v].emplace_back(u); } } vis.assign(n+5, false); reverse(order.begin(), order.end()); for (auto u : order) { if (vis[u]) { continue; } vector<int> component; dfs(u, adj_T, vis, component); int root = *min_element(component.begin(), component.end()); for (auto v : adj[u]) { scc[v] = u; } } return scc; }","title":"Strongly Connected Component"},{"location":"template/#inverse-modulo","text":"#define MOD ... // a in range [1...m-1] int inv(int a) { return a <= 1 ? a : MOD - (long long)(MOD/a) * inv(MOD % a) % MOD; } // Precompute all modulo inverse [1...m-1] int inv[MOD]; inv[1] = 1; for(int a = 2; a < MOD; ++a) { inv[a] = MOD - (long long)(MOD/a) * inv[MOD%a] % MOD; }","title":"Inverse Modulo"},{"location":"template/#sieve-of-eratosthenes","text":"// Function to precompute all factors for numbers from 1..N vector<vector<int>> compute_factors(int N) { vector<vector<int>> factors(N + 1); for (int i = 1; i <= N; ++i) { for (int j = i; j <= N; j += i) { factors[j].push_back(i); } } return factors; } // Precompute all primes up to N using Sieve of Eratosthenes vector<bool> compute_primes(int N) { vector<bool> is_prime(N + 1, true); is_prime[0] = is_prime[1] = false; for (int i = 2; i * i <= N; ++i) { if (is_prime[i]) { for (int j = i * i; j <= N; j += i) { is_prime[j] = false; } } } return is_primes; }","title":"Sieve of Eratosthenes"},{"location":"template/#grahams-scan","text":"struct pt { long long x, y; pt() {} pt(long long _x, long long _y) : x(_x), y(_y) {} pt operator+(const pt &p) const { return pt(x + p.x, y + p.y); } pt operator-(const pt &p) const { return pt(x - p.x, y - p.y); } long long cross(const pt &p) const { return x * p.y - y * p.x; } long long dot(const pt &p) const { return x * p.x + y * p.y; } long long cross(const pt &a, const pt &b) const { return (a - *this).cross(b - *this); } long long dot(const pt &a, const pt &b) const { return (a - *this).dot(b - *this); } long long sqrLen() const { return this->dot(*this); } bool operator==(const pt& t) const { return x == t.x && y == t.y; } }; int orientation(const pt &a, const pt &b, const pt &c) { long long v = a.cross(b, c); if (v < 0) return -1; // clockwise if (v > 0) return 1; // counter-clockwise return 0; // collinear } bool cw(const pt &a, const pt &b, const pt &c, bool include_collinear) { int o = orientation(a, b, c); return o < 0 || (include_collinear && o == 0); } bool collinear(const pt &a, const pt &b, const pt &c) { return orientation(a, b, c) == 0; } void convex_hull(vector<pt>& a, bool include_collinear = false) { if (a.size() <= 1) return; pt p0 = *min_element(a.begin(), a.end(), [](const pt &a, const pt &b) { return make_pair(a.y, a.x) < make_pair(b.y, b.x); }); sort(a.begin(), a.end(), [&p0](const pt &a, const pt &b) { int o = orientation(p0, a, b); if (o == 0) // collinear, closer first return (p0 - a).sqrLen() < (p0 - b).sqrLen(); return o < 0; // clockwise order }); if (include_collinear) { int i = (int)a.size() - 1; while (i >= 0 && collinear(p0, a[i], a.back())) i--; reverse(a.begin() + i + 1, a.end()); } vector<pt> st; for (int i = 0; i < (int)a.size(); i++) { while (st.size() > 1 && !cw(st[st.size()-2], st.back(), a[i], include_collinear)) st.pop_back(); st.push_back(a[i]); } if (!include_collinear && st.size() == 2 && st[0] == st[1]) st.pop_back(); a = st; }","title":"Graham's scan"}]}