<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Template - K1EW CP Template</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Template";
        var mkdocs_page_input_path = "template.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> K1EW CP Template
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Template</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#fast-io">Fast IO</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#disjoint-set-union">Disjoint Set Union</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#segment-tree">Segment Tree</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lazy-propagation-segment-tree">Lazy Propagation Segment Tree</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#heavy-light-decomposition">Heavy-Light Decomposition</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#heavy-light-decomposition-with-range-update">Heavy-Light Decomposition with Range Update</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mos-algorithm">Mo's algorithm</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#strongly-connected-component">Strongly Connected Component</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#inverse-modulo">Inverse Modulo</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sieve-of-eratosthenes">Sieve of Eratosthenes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#grahams-scan">Graham's scan</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">K1EW CP Template</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Template</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="template">Template</h1>
<h2 id="fast-io">Fast IO</h2>
<pre><code class="language-cpp">std::ios_base::sync_with_stdio(false);
std::cin.tie(0);
</code></pre>
<h2 id="disjoint-set-union">Disjoint Set Union</h2>
<pre><code class="language-cpp">struct DSU {
    vector&lt;int&gt; parent;
    vector&lt;int&gt; rank;
    DSU(int n) {
        parent.assign(n+5, 0);
        rank.assign(n+5, 0);
        for (int i=1;i&lt;=n;i++) { parent[i] = i; }
    }
    int find(int u) {
        if (parent[u] == u) { return u; }
        return parent[u] = find(parent[u]);
    }
    void union_sets(int u, int v) {
        u = find(u);
        v = find(v);
        if (u != v) {
            if (rank[u] &lt; rank[v]) { swap(u, v); }
            parent[v] = u;
            rank[u] += rank[v];
        }
    }
};
</code></pre>
<h2 id="segment-tree">Segment Tree</h2>
<pre><code class="language-cpp">// Example: max point update &amp; max range query
struct SegTree {
    vector&lt;int&gt; tree; 
    SegTree(int n) {
        tree.assign(4*n+5, 0); 
    }
    int merge_segment(const int &amp;seg1, const int &amp;seg2) {
        return max(seg1, seg2);
    }
    void build(int a[], int v, int tl, int tr) {
        if (tl == tr) {
            tree[v] = a[tl]; 
        } else {
            int tm = (tl + tr) &gt;&gt; 1;
            build(a, v*2, tl, tm);
            build(a, v*2+1, tm+1, tr);
            tree[v] = merge_segment(tree[v*2], tree[v*2+1]); 
        }
    }
    void update(int v, int tl, int tr, int pos, int val) {
        if (tl == tr) {
            tree[v] = max(tree[v], val); 
        } else {
            int tm = (tl + tr) &gt;&gt; 1;
            if (pos &lt;= tm) { update(v*2, tl, tm, pos, val); }
            else { update(v*2+1, tm+1, tr, pos, val); }
            tree[v] = merge_segment(tree[v*2], tree[v*2+1]); 
        }
    }
    int query(int v, int tl, int tr, int l, int r) { 
        if (tr &lt; l || r &lt; tl) { return 0; }
        if (l &lt;= tl &amp;&amp; tr &lt;= r) {
            return tree[v];
        }
        int tm = (tl + tr) &gt;&gt; 1;
        return merge_segment(
            query(v*2, tl, tm, l, r),
            query(v*2+1, tm+1, tr, l, r)
        );
    }
};
</code></pre>
<h2 id="lazy-propagation-segment-tree">Lazy Propagation Segment Tree</h2>
<pre><code class="language-cpp">// Example: sum range update &amp; range query
struct LazySegTree {
    vector&lt;int&gt; tree; 
    vector&lt;int&gt; lazy; 
    LazySegTree(int n) {
        tree.assign(4*n+5, 0); 
        lazy.assign(4*n+5, 0); 
    }
    int merge_segment(const int &amp;seg1, const int &amp;seg2) {
        return seg1 + seg2;
    }
    void apply(int v, int x, int tl, int tr) {
        tree[v] += x * (tr - tl + 1);
        lazy[v] += x;
    }
    void push(int v, int tl, int tr) {
        if (!lazy[v]) { return; } 
        int tm = (tl + tr) &gt;&gt; 1;
        apply(v*2, lazy[v], tl, tm);
        apply(v*2+1, lazy[v], tm+1, tr);
        lazy[v] = 0; 
    }
    void build(int a[], int v, int tl, int tr) {
        if (tl == tr) {
            tree[v] = a[tl];
        } else {
            int tm = (tl + tr) &gt;&gt; 1;
            build(a, v*2, tl, tm);
            build(a, v*2+1, tm+1, tr);
            tree[v] = merge_segment(tree[v*2], tree[v*2+1]); 
        }
    }
    void update(int v, int tl, int tr, int l, int r, int val) {
        if (tr &lt; l || r &lt; tl) { return; }
        if (l &lt;= tl &amp;&amp; tr &lt;= r) {
            apply(v, val, tl, tr);
        } else {
            push(v, tl, tr);
            int tm = (tl + tr) &gt;&gt; 1;
            update(v*2, tl, tm, l, r, val); 
            update(v*2+1, tm+1, tr, l, r, val); 
            tree[v] = merge_segment(tree[v*2], tree[v*2+1]); 
        }
    }
    int query(int v, int tl, int tr, int l, int r) { 
        if (tr &lt; l || r &lt; tl) { return 0; }
        if (l &lt;= tl &amp;&amp; tr &lt;= r) {
            return tree[v];
        }
        push(v, tl, tr);
        int tm = (tl + tr) &gt;&gt; 1;
        return merge_segment(
            query(v*2, tl, tm, l, r),
            query(v*2+1, tm+1, tr, l, r)
        );
    }
};
</code></pre>
<h2 id="heavy-light-decomposition">Heavy-Light Decomposition</h2>
<pre><code class="language-cpp">vector&lt;int&gt; adj[MXN];
int sz[MXN], parent[MXN], depth[MXN], tin[MXN], tout[MXN], top[MXN];
int n;
void dfs1(int u, int p) {
    sz[u] = 1;
    vector&lt;int&gt; children;
    for (auto v : adj[u]) {
        if (v == p) { continue; }
        depth[v] = depth[u] + 1;
        dfs1(v, u);
        children.emplace_back(v);
        sz[u] += sz[v];
        parent[v] = u;
    }
    swap(adj[u], children);
}
int dfs2(int u, int timer) {
    tin[u] = timer;
    for (auto v : adj[u]) {
        if (v == adj[u][0]) {
            top[v] = top[u];
        } else {
            top[v] = v;
        }
        timer = dfs2(v, timer+1);
    }
    tout[u] = timer + 1;
    return timer;
}
void hld(int root) {
    dfs1(root, -1);
    for (int i=1;i&lt;=n;i++) {
        sort(adj[i].begin(), adj[i].end(), [&amp;](const int &amp;u, const int &amp;v) {
            return sz[u] &gt; sz[v];
        });
    }
    top[root] = root;
    dfs2(root, 1);
}
void point_update(SegTree &amp;segtree, int u, int val) {
    segtree.update(1, 1, n, tin[u], val);
}
int query_subtree(SegTree &amp;segtree, int u) {
    return segtree.query(1, 1, n, tin[u], tout[u] - 1);
}
int query_path(SegTree &amp;segtree, int u, int v) {
    int res = 0;
    while (top[u] != top[v]) {
        if (depth[top[u]] &lt; depth[top[v]]) {
            swap(u, v);
        }
        res = segtree.merge_segment(res, segtree.query(1, 1, n, tin[top[u]], tin[u]));
        u = parent[top[u]];
    }
    res = segtree.merge_segment(res, segtree.query(1, 1, n, min(tin[u], tin[v]), max(tin[u], tin[v])));
    return res;
}
</code></pre>
<h2 id="heavy-light-decomposition-with-range-update">Heavy-Light Decomposition with Range Update</h2>
<pre><code class="language-cpp">void range_update(LazySegTree &amp;segtree, int u, int v, int val) {
    while (top[u] != top[v]) {
        if (depth[top[u]] &lt; depth[top[v]]) {
            swap(u, v);
        }
        segtree.update(1, 1, n, tin[top[u]], tin[u], val);
        u = parent[top[u]];
    }
    segtree.update(1, 1, n, min(tin[u], tin[v]), max(tin[u], tin[v]), val);
}
</code></pre>
<h2 id="mos-algorithm">Mo's algorithm</h2>
<pre><code class="language-cpp">#define BLOCK_SIZE 450
void add(int idx) {
}
void remove(int idx) {
}
struct Query {
    int l, r, idx;
    Query(int l, int r, int idx) {
        this-&gt;l = l;
        this-&gt;r = r;
        this-&gt;idx = idx;
    }
    bool operator&lt;(const Query &amp;other) const {
        if (l / BLOCK_SIZE != other.l / BLOCK_SIZE) {
            return make_pair(l / BLOCK_SIZE, r) &lt;
                   make_pair(other.l / BLOCK_SIZE, other.r);
        }
        return (l / BLOCK_SIZE % 2) ? (r &lt; other.r) : (r &gt; other.r);
    }
};
vector&lt;int&gt; mo(int q, vector&lt;Query&gt; &amp;queries) {
    vector&lt;int&gt; ans(q);
    sort(queries.begin(), queries.end());
    int l = 1, r = 0;
    for (Query q : queries) {
        while (r &lt; q.r) { add(++r); }
        while (r &gt; q.r) { remove(r--); }
        while (l &gt; q.l) { add(--l); }
        while (l &lt; q.l) { remove(l++); }
        // ans[q.idx] = ...
    }
    return ans;
}
</code></pre>
<h2 id="strongly-connected-component">Strongly Connected Component</h2>
<pre><code class="language-cpp">void dfs(int u, vector&lt;int&gt; adj[],  vector&lt;bool&gt; &amp;vis, vector&lt;int&gt; &amp;output) {
    vis[u] = true;
    for (auto v : adj[u]) {
        if (vis[v]) { continue; }
        dfs(v, adj, vis, output);
    }
    output.emplace_back(u);
}

vector&lt;int&gt; find_scc(int n, vector&lt;int&gt; adj[]) {
    vector&lt;int&gt; scc(n+5);

    vector&lt;int&gt; order;
    vector&lt;bool&gt; vis(n+5);
    for (int v=1;v&lt;=n;v++) {
        if (vis[v]) { continue; }
        dfs(v, adj, vis, order);
    }

    vector&lt;int&gt; adj_T[n+5];
    for (int u=1;u&lt;=n;u++) { adj[u].clear(); }
    for (int u=1;u&lt;=n;u++) {
        for (auto v: adj[u]) {
            adj_T[v].emplace_back(u);
        }
    }

    vis.assign(n+5, false);
    reverse(order.begin(), order.end());
    for (auto u : order) {
        if (vis[u]) { continue; }
        vector&lt;int&gt; component;
        dfs(u, adj_T,  vis, component);
        int root = *min_element(component.begin(), component.end());
        for (auto v : adj[u]) {
            scc[v] = u;
        }
    }

    return scc;
}
</code></pre>
<h2 id="inverse-modulo">Inverse Modulo</h2>
<pre><code class="language-cpp">#define MOD ...
// a in range [1...m-1]
int inv(int a) {
    return a &lt;= 1 ? a : MOD - (long long)(MOD/a) * inv(MOD % a) % MOD;
}
// Precompute all modulo inverse [1...m-1]
int inv[MOD];
inv[1] = 1;
for(int a = 2; a &lt; MOD; ++a) {
    inv[a] = MOD - (long long)(MOD/a) * inv[MOD%a] % MOD;
}
</code></pre>
<h2 id="sieve-of-eratosthenes">Sieve of Eratosthenes</h2>
<pre><code class="language-cpp">// Function to precompute all factors for numbers from 1..N
vector&lt;vector&lt;int&gt;&gt; compute_factors(int N) {
    vector&lt;vector&lt;int&gt;&gt; factors(N + 1);
    for (int i = 1; i &lt;= N; ++i) {
        for (int j = i; j &lt;= N; j += i) {
            factors[j].push_back(i);
        }
    }
    return factors;
}
// Precompute all primes up to N using Sieve of Eratosthenes
vector&lt;bool&gt; compute_primes(int N) {
    vector&lt;bool&gt; is_prime(N + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i &lt;= N; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j &lt;= N; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return is_primes;
}
</code></pre>
<h2 id="grahams-scan">Graham's scan</h2>
<pre><code class="language-cpp">struct pt {
    long long x, y;
    pt() {}
    pt(long long _x, long long _y) : x(_x), y(_y) {}
    pt operator+(const pt &amp;p) const { return pt(x + p.x, y + p.y); }
    pt operator-(const pt &amp;p) const { return pt(x - p.x, y - p.y); }
    long long cross(const pt &amp;p) const { return x * p.y - y * p.x; }
    long long dot(const pt &amp;p) const { return x * p.x + y * p.y; }
    long long cross(const pt &amp;a, const pt &amp;b) const { return (a - *this).cross(b - *this); }
    long long dot(const pt &amp;a, const pt &amp;b) const { return (a - *this).dot(b - *this); }
    long long sqrLen() const { return this-&gt;dot(*this); }
    bool operator==(const pt&amp; t) const { return x == t.x &amp;&amp; y == t.y; }
};
int orientation(const pt &amp;a, const pt &amp;b, const pt &amp;c) {
    long long v = a.cross(b, c);
    if (v &lt; 0) return -1; // clockwise
    if (v &gt; 0) return 1;  // counter-clockwise
    return 0;             // collinear
}
bool cw(const pt &amp;a, const pt &amp;b, const pt &amp;c, bool include_collinear) {
    int o = orientation(a, b, c);
    return o &lt; 0 || (include_collinear &amp;&amp; o == 0);
}
bool collinear(const pt &amp;a, const pt &amp;b, const pt &amp;c) {
    return orientation(a, b, c) == 0;
}
void convex_hull(vector&lt;pt&gt;&amp; a, bool include_collinear = false) {
    if (a.size() &lt;= 1) return;
    pt p0 = *min_element(a.begin(), a.end(), [](const pt &amp;a, const pt &amp;b) {
        return make_pair(a.y, a.x) &lt; make_pair(b.y, b.x);
    });
    sort(a.begin(), a.end(), [&amp;p0](const pt &amp;a, const pt &amp;b) {
        int o = orientation(p0, a, b);
        if (o == 0) // collinear, closer first
            return (p0 - a).sqrLen() &lt; (p0 - b).sqrLen();
        return o &lt; 0; // clockwise order
    });
    if (include_collinear) {
        int i = (int)a.size() - 1;
        while (i &gt;= 0 &amp;&amp; collinear(p0, a[i], a.back())) i--;
        reverse(a.begin() + i + 1, a.end());
    }
    vector&lt;pt&gt; st;
    for (int i = 0; i &lt; (int)a.size(); i++) {
        while (st.size() &gt; 1 &amp;&amp; !cw(st[st.size()-2], st.back(), a[i], include_collinear))
            st.pop_back();
        st.push_back(a[i]);
    }
    if (!include_collinear &amp;&amp; st.size() == 2 &amp;&amp; st[0] == st[1])
        st.pop_back();
    a = st;
}
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
